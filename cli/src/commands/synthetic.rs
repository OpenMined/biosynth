use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::PathBuf;
use std::sync::Arc;

use anyhow::{anyhow, bail, Context, Result};
use chrono::NaiveDate;
use rand::rngs::StdRng;
use rand::{Rng, SeedableRng};
use rayon::prelude::*;
use rayon::ThreadPoolBuilder;
use serde::Deserialize;

use crate::download::ensure_reference_db;
use crate::stats::{ReferenceVariant, StatsStore};
use crate::SyntheticArgs;

const HEADER_TEXT: &str = r#"# This data file generated by Dynamic DNA (DDNA) Laboratories at: Thu Nov 7 16:03:14 2024
#						
# This file contains raw genetic data, including data that is not used in DDNA reports. 						
# This data has undergone a general quality review however only a subset of markers have been 						
# individually reviewed for accuracy. As such, this data is suitable only for research,  						
# educational, and informational use and not for any medical or diagnostic use. 						
# 						
# Below is a text version of your data.  Fields are TAB-separated and						
# each line corresponds to a single SNP.  For each SNP, we provide its identifier,  						
# it chromosomal location realtive to Build 38 of the human reference genome, and the 						
# genotype call oriented with respect to the plus strand on the human reference sequence.						
# More information about Dynamic DNA Laboratories can be found at:						
# https://dynamicdnalabs.com						
# 						
# More information on reference human assembly builds:						
# https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_000001405.40/						
#						
# rsid	chromosome	position	genotype	gs	baf	lrr
"#;

enum VariantKind {
    Snp,
    Mnv,
    Insertion,
    Deletion,
}

pub fn run_synthetic(args: SyntheticArgs) -> Result<()> {
    if !(0.0..=1.0).contains(&args.alt_frequency) {
        bail!("--alt-frequency must be between 0 and 1");
    }
    if args.count == 0 {
        bail!("--count must be at least 1");
    }
    let output_template = args.output.to_string_lossy().to_string();
    if args.count > 1 && !(output_template.contains("{index}") || output_template.contains("{id}"))
    {
        bail!("When --count > 1, --output must include an '{{index}}' or '{{id}}' placeholder");
    }
    if args.id_min > args.id_max {
        bail!("--id-min must be <= --id-max");
    }
    if args.month_min < 1 || args.month_max > 12 || args.month_min > args.month_max {
        bail!("Month range must be between 1 and 12");
    }
    if args.day_min < 1 || args.day_max > 31 || args.day_min > args.day_max {
        bail!("Day range must be between 1 and 31");
    }

    let sqlite_path = ensure_reference_db(Some(&args.sqlite))?;
    let store = StatsStore::connect(&sqlite_path)?;
    let references = store.all_references(args.limit)?;
    if references.is_empty() {
        bail!(
            "No reference rows found in {}",
            sqlite_path.to_string_lossy()
        );
    }
    let references = Arc::new(references);

    let overlays = load_overlay_specs(&args)?
        .map(Arc::new)
        .unwrap_or_else(|| Arc::new(Vec::new()));

    let plans = build_file_plans(&output_template, &args)?;

    let thread_count = args
        .threads
        .unwrap_or_else(|| rayon::current_num_threads().max(1));
    let pool = ThreadPoolBuilder::new()
        .num_threads(thread_count)
        .build()
        .context("build synthetic thread pool")?;

    let results: Vec<usize> = pool.install(|| {
        plans
            .par_iter()
            .map(|plan| {
                write_single_file(
                    &plan.path,
                    references.as_ref(),
                    overlays.as_ref(),
                    args.alt_frequency,
                    plan.seed,
                )
            })
            .collect::<Result<Vec<_>>>()
    })?;

    let total_rows: usize = results.iter().sum();
    println!(
        "ðŸ§ª Generated {} file(s), {} total rows (alt freq {:.2}%)",
        results.len(),
        total_rows,
        args.alt_frequency * 100.0
    );
    Ok(())
}

fn write_single_file(
    path: &PathBuf,
    references: &[ReferenceVariant],
    overlays: &[OverlaySpec],
    alt_frequency: f64,
    seed: Option<u64>,
) -> Result<usize> {
    if let Some(parent) = path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent)
                .with_context(|| format!("Create directory {:?}", parent))?;
        }
    }
    let mut rng = match seed {
        Some(seed) => StdRng::seed_from_u64(seed),
        None => StdRng::from_entropy(),
    };

    let mut overlay_assignments = prepare_overlay_assignments(overlays, &mut rng)?;

    let file = File::create(path).with_context(|| format!("Create {:?}", path))?;
    let mut writer = BufWriter::new(file);
    writer
        .write_all(HEADER_TEXT.as_bytes())
        .context("write header")?;

    let mut written = 0usize;
    for reference in references {
        if let Some(assignment) = overlay_assignments.remove(&reference.rsid) {
            write_overlay_row(&mut writer, &assignment, &mut rng)?;
            written += 1;
            continue;
        }

        let genotype = synthesize_genotype(reference, alt_frequency, &mut rng);
        let gs = rng.gen_range(0.2..=1.0);
        let baf = rng.gen_range(0.0..=1.0);
        let lrr = rng.gen_range(-0.5..=0.5);
        let rsid_label = format!("rs{}", reference.rsid);
        writeln!(
            writer,
            "{}\t{}\t{}\t{}\t{:.4}\t{:.3}\t{:.4}",
            rsid_label, reference.chromosome, reference.position, genotype, gs, baf, lrr
        )
        .with_context(|| format!("write row for rs{}", reference.rsid))?;
        written += 1;
    }

    for assignment in overlay_assignments.into_values() {
        write_overlay_row(&mut writer, &assignment, &mut rng)?;
        written += 1;
    }

    writer.flush()?;
    Ok(written)
}

fn write_overlay_row(
    writer: &mut BufWriter<File>,
    assignment: &OverlayAssignment,
    rng: &mut StdRng,
) -> Result<()> {
    let gs = rng.gen_range(0.2..=1.0);
    let baf = rng.gen_range(0.0..=1.0);
    let lrr = rng.gen_range(-0.5..=0.5);
    let rsid_label = format!("rs{}", assignment.spec.rsid);
    writeln!(
        writer,
        "{}\t{}\t{}\t{}\t{:.4}\t{:.3}\t{:.4}",
        rsid_label,
        assignment.spec.chromosome,
        assignment.spec.position,
        assignment.genotype,
        gs,
        baf,
        lrr
    )
    .with_context(|| format!("write overlay row for {}", assignment.spec.rsid))
}

fn load_overlay_specs(args: &SyntheticArgs) -> Result<Option<Vec<OverlaySpec>>> {
    let json_source = match (&args.variants_file, &args.variants_json) {
        (Some(_), Some(_)) => {
            bail!("Use only one of --variants-file or --variants-json");
        }
        (Some(path), None) => Some(
            std::fs::read_to_string(path)
                .with_context(|| format!("Read variants JSON file {:?}", path))?,
        ),
        (None, Some(inline)) => Some(inline.clone()),
        (None, None) => None,
    };

    let Some(raw_json) = json_source else {
        return Ok(None);
    };

    let root: OverlayRoot =
        serde_json::from_str(&raw_json).context("Parse variants JSON payload")?;
    let mut specs = Vec::new();
    for group in root.groups.values() {
        for variant in &group.variants {
            specs.push(OverlaySpec::from_raw(variant)?);
        }
    }
    Ok(Some(specs))
}

fn prepare_overlay_assignments(
    overlays: &[OverlaySpec],
    rng: &mut StdRng,
) -> Result<HashMap<i64, OverlayAssignment>> {
    let mut assignments: HashMap<i64, OverlayAssignment> = HashMap::new();
    for spec in overlays {
        let genotype = spec.random_genotype(rng)?;
        if assignments
            .insert(
                spec.rsid,
                OverlayAssignment {
                    spec: spec.clone(),
                    genotype,
                },
            )
            .is_some()
        {
            bail!("Duplicate overlay rsid detected: {}", spec.rsid);
        }
    }
    Ok(assignments)
}

#[derive(Debug, Clone)]
struct OverlaySpec {
    rsid: i64,
    chromosome: String,
    position: i64,
    genotype_options: Vec<String>,
}

impl OverlaySpec {
    fn from_raw(raw: &OverlayVariantRaw) -> Result<Self> {
        let rsid = raw
            .rsid
            .trim()
            .trim_start_matches("rs")
            .parse::<i64>()
            .with_context(|| format!("parse overlay rsid {}", raw.rsid))?;
        let genotype_options = if let Some(options) = &raw.genotypes {
            if options.is_empty() {
                bail!("Variant {} has empty genotype list", raw.rsid);
            }
            options.clone()
        } else if let Some(reference) = &raw.reference {
            let alternates = raw
                .alternates
                .clone()
                .unwrap_or_else(|| vec![reference.clone()]);
            generate_genotype_combinations(reference, &alternates)
        } else {
            bail!(
                "Variant {} must specify either genotypes or reference/alternates",
                raw.rsid
            );
        };

        Ok(Self {
            rsid,
            chromosome: raw.chromosome.clone(),
            position: raw.position,
            genotype_options,
        })
    }

    fn random_genotype(&self, rng: &mut StdRng) -> Result<String> {
        if self.genotype_options.is_empty() {
            bail!("Variant {} has no genotype options", self.rsid);
        }
        let idx = rng.gen_range(0..self.genotype_options.len());
        Ok(self.genotype_options[idx].clone())
    }
}

struct OverlayAssignment {
    spec: OverlaySpec,
    genotype: String,
}

#[derive(Debug, Clone)]
struct FilePlan {
    path: PathBuf,
    seed: Option<u64>,
}

fn build_file_plans(template: &str, args: &SyntheticArgs) -> Result<Vec<FilePlan>> {
    let mut rng = StdRng::from_entropy();
    let mut used_ids: HashSet<u32> = HashSet::new();
    let range_size = args.id_max.saturating_sub(args.id_min).saturating_add(1) as usize;
    if args.count > range_size && template.contains("{id}") {
        bail!(
            "ID range ({:?}-{:?}) is too small for {} unique files",
            args.id_min,
            args.id_max,
            args.count
        );
    }

    let mut plans = Vec::with_capacity(args.count);
    for idx in 0..args.count {
        let id = if template.contains("{id}") {
            generate_unique_id(args.id_min, args.id_max, &mut used_ids, &mut rng)?
        } else {
            0
        };

        let (date_str, month, day) = if template.contains("{date}")
            || template.contains("{month}")
            || template.contains("{day}")
            || template.contains("{year}")
        {
            let month = rng.gen_range(args.month_min..=args.month_max);
            let day = rng.gen_range(args.day_min..=args.day_max);
            let date = NaiveDate::from_ymd_opt(args.date_year, month, day).ok_or_else(|| {
                anyhow!(
                    "Invalid date generated: {}/{}/{}",
                    month,
                    day,
                    args.date_year
                )
            })?;
            let formatted = date.format(&args.date_format).to_string();
            (formatted, month, day)
        } else {
            (String::new(), 0, 0)
        };

        let path_str =
            fill_output_template(template, idx, id, &date_str, month, day, args.date_year);
        let seed = args.seed.map(|base| base + idx as u64);
        plans.push(FilePlan {
            path: PathBuf::from(path_str),
            seed,
        });
    }

    Ok(plans)
}

fn generate_unique_id(
    min: u32,
    max: u32,
    used: &mut HashSet<u32>,
    rng: &mut StdRng,
) -> Result<u32> {
    for _ in 0..10_000 {
        let candidate = rng.gen_range(min..=max);
        if used.insert(candidate) {
            return Ok(candidate);
        }
    }
    bail!("Failed to generate unique participant ID within range");
}

fn fill_output_template(
    template: &str,
    index: usize,
    id: u32,
    date_str: &str,
    month: u32,
    day: u32,
    year: i32,
) -> String {
    let mut result = template.to_string();
    if result.contains("{index}") {
        result = result.replace("{index}", &format!("{:04}", index + 1));
    }
    if result.contains("{id}") {
        result = result.replace("{id}", &format!("{:06}", id));
    }
    if result.contains("{date}") {
        result = result.replace("{date}", date_str);
    }
    if result.contains("{month}") {
        result = result.replace("{month}", &format!("{:02}", month));
    }
    if result.contains("{day}") {
        result = result.replace("{day}", &format!("{:02}", day));
    }
    if result.contains("{year}") {
        result = result.replace("{year}", &year.to_string());
    }
    result
}

#[derive(Debug, Deserialize)]
struct OverlayRoot {
    #[serde(flatten)]
    groups: HashMap<String, OverlayGroup>,
}

#[derive(Debug, Deserialize)]
struct OverlayGroup {
    variants: Vec<OverlayVariantRaw>,
}

#[derive(Debug, Deserialize)]
struct OverlayVariantRaw {
    rsid: String,
    chromosome: String,
    position: i64,
    #[serde(default)]
    genotypes: Option<Vec<String>>,
    reference: Option<String>,
    alternates: Option<Vec<String>>,
}

fn generate_genotype_combinations(reference: &str, alternates: &[String]) -> Vec<String> {
    let mut alleles = Vec::new();
    alleles.push(reference.to_string());
    for alt in alternates {
        if !alt.is_empty() {
            alleles.push(alt.clone());
        }
    }
    alleles.sort();
    alleles.dedup();

    let mut combos = Vec::new();
    for i in 0..alleles.len() {
        for j in i..alleles.len() {
            let combo = format!("{}{}", alleles[i], alleles[j]);
            combos.push(combo);
        }
    }
    combos
}

fn synthesize_genotype(
    reference: &ReferenceVariant,
    alt_frequency: f64,
    rng: &mut StdRng,
) -> String {
    let alt_list = reference
        .alternates
        .split(',')
        .map(|alt| alt.trim())
        .filter(|alt| !alt.is_empty())
        .collect::<Vec<_>>();
    let kind = determine_variant_kind(reference, &alt_list);
    let use_alt = !alt_list.is_empty() && rng.gen::<f64>() < alt_frequency;

    match kind {
        VariantKind::Snp | VariantKind::Mnv => {
            let allele = if use_alt {
                alt_list[rng.gen_range(0..alt_list.len())]
            } else {
                reference.reference.as_str()
            };
            let symbol = match kind {
                VariantKind::Snp => allele.to_string(),
                VariantKind::Mnv => allele
                    .chars()
                    .next()
                    .map(|c| c.to_string())
                    .unwrap_or_else(|| "?".into()),
                _ => unreachable!(),
            };
            format!("{symbol}{symbol}")
        }
        VariantKind::Insertion | VariantKind::Deletion => {
            let (ref_symbol, alt_symbol) = match kind {
                VariantKind::Insertion => ("D", "I"),
                VariantKind::Deletion => ("I", "D"),
                _ => unreachable!(),
            };
            let symbol = if use_alt { alt_symbol } else { ref_symbol };
            format!("{symbol}{symbol}")
        }
    }
}

fn determine_variant_kind(reference: &ReferenceVariant, alts: &[&str]) -> VariantKind {
    let ref_len = reference.reference.len();
    if alts.is_empty() {
        return VariantKind::Snp;
    }
    if ref_len == 1 && alts.iter().all(|alt| alt.len() == 1) {
        return VariantKind::Snp;
    }
    let first_alt_len = alts[0].len();
    let all_alt_same_len = alts.iter().all(|alt| alt.len() == ref_len);
    if all_alt_same_len && ref_len > 1 {
        VariantKind::Mnv
    } else if first_alt_len > ref_len {
        VariantKind::Insertion
    } else if first_alt_len < ref_len {
        VariantKind::Deletion
    } else {
        VariantKind::Mnv
    }
}
